---
title: Go语言的垃圾回收
tags:
---

这两天我尝试去了解Go语言的垃圾回收，但很多博文并没有解决我的疑问，于是在参考各类资料后，决定在年底的最后一天，记录一下相关的内容。

### 垃圾回收的定义

在了解Go语言的垃圾回收机制之前，我们需要先简单了解一下什么是垃圾回收。

首先，什么是垃圾？根据[维基百科](https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8))的定义，被程序占用但不会再被该程序访问的内存空间被称为垃圾。程序一般会使用两种内存，分别是栈和堆。栈用于存储函数调用所需的局部变量和函数调用信息，栈数据的生命周期与函数的调用直接相关。当函数执行完成时，栈空间就可以通过移动栈顶指针被轻松释放，因此这些数据不用垃圾回收器回收。但是栈空间、数据段可能存储着堆数据的指针，这些堆数据的生命周期独立于函数调用，可能会有多个指针引用，因此需要垃圾回收器来追踪和管理这些对象的生命周期。总而言之，垃圾指的是程序在堆上分配的、且后续不会再访问的内存空间。

其次，什么时候回收垃圾？一些语言将垃圾回收的责任交给了程序的编写者，如C、C++需要在分配堆内存后手动地回收这些空间，以避免内存泄露。而Go、Java等语言则是语言内部提供了垃圾回收器，让语言的使用者不用操心内存的问题。对于Go而言，回收垃圾的触发场景为：

1. 堆大小达到阈值。
2. 距离上一次GC超过一定时间，默认为2分钟。 (https://github.com/golang/go/issues/44163)
3. 手动通过`runtime.GC`方法触发垃圾回收。

接下来，我们了解一下Go语言垃圾回收方法的演变。

### 标记清除

对于垃圾回收，一个简单明了的方法是标记清除算法（Mark and Sweep），Go 1.3版本前用的就是这个方法。

![Exploring the Inner Workings of Garbage Collection in Golang : Tricolor Mark  and Sweep | by Sourav Choudhary | Medium](https://oss.seineo.cn/images/202312311615331.gif)

<center>https://medium.com/@souravchoudhary0306/exploring-the-inner-workings-of-garbage-collection-in-golang-tricolor-mark-and-sweep-e10eae164a12</center>

这是基于可达性分析或者说基于追踪的方法，先暂停程序的所有用户协程，让回收器协程从垃圾回收的根节点开始，不断遍历对象图，直到遍历完所有可达的对象节点，剩余不可达的节点则是需要回收的节点。

其中垃圾回收的根节点是指全局变量和栈空间中指向堆对象的指针，从这些对象开始，可以找到所有活跃的堆对象。

这一简单粗暴的方法主要有两个缺点：

1. 程序完全暂停（STW），导致程序的可用性很差。
2. 会产生大量的空闲空间碎片，和使大容量对象不容易获得连续的内存空间，而造成空间浪费。

对于第一点，Go语言当时饱受诟病，能够并发地完成垃圾回收是急需完成的目标。

对于第二点，[资料](https://zhuanlan.zhihu.com/p/605315127)谈到Go语言使用TCMalloc这一内存分配算法，能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中。

### 三色标记

让用户协程与回收器协程并发执行，会带来许多问题。

第一个问题，回收器从用户协程上下文切换回来后，如何继续执行标记清除这一过程？

![截屏2023-12-31 16.25.37](https://oss.seineo.cn/images/202312311625159.png)

以上图为例，切换回来后，不知道从哪里继续，虽然图中可以看出，但是实际算法并不知道哪些黑色节点是进一步要处理子节点的（比如在层次遍历遍历某一层到一半切换了），这一问题所在是由于二色标记法只描述了扫描结果，而没有描述扫描的当前状态。

因此，Dijkstra提出三色标记法，引入中间状态：灰色节点，用于表示这个节点被标记了，但是子节点还未处理，每次切换回来处理灰色节点即可。（最开始都是白色对象，然后将根节点标记为灰色，逐层遍历）



第二个问题，并发过程中，用户协程修改了对象的引用关系怎么办？

比如已标记的黑色节点，创建了对新的堆对象的引用，那么该新对象会是白色的，或者取消灰色对白色的引用，同时加上黑色对该白色的引用， 这都会使得该白色对象被误回收。

可以发现，这一问题的出现需要满足两个必要条件：

1. 黑色对象指向白色对象。
2. 灰色对象丢失了该白色对象。

### 三色标记+插入写屏障

解决以上问题，只需要破解两个必要条件之一即可，也就是达成以下两种三色不变性中的一种即可。

1. 强三色不变性。 黑色对象不会指向白色对象。黑色对象只能指向灰色或者黑色对象。
2. 弱三色不变性。 黑色对象可以指向白色对象，但是必须包含一条从灰色对象到该白色对象的路径。

为了达成这两种三色不变性，屏障技术被提出。屏障技术类似钩子函数，是在用户程序读取、创建、更新对象指针时被执行的一段代码，Go语言中使用了两种写屏障技术：Dijkstra提出的插入写屏障和Yuasa提出的删除写屏障。

插入写屏障：

```pseudocode
writePointer(slot, ptr):
	shade(ptr)
	*slot = ptr
```

每当执行类似`*slot=ptr`这种修改指针引用的代码时，我们那都会提前执行`shade`函数来改变指针的颜色为灰色。



删除写屏障：

```pseudocode
writePointer(slot, ptr):
	shade(*slot)
	*slot = ptr
```

在老对象的引用被删除时，将白色的老对象改为灰色，这样就保证了老对象及其下游对象一定可以最后可以被标记。为什么引用被删除还要标记为灰色？因为后续该对象可能被其他对象引用，如果最终没有被引用，该对象和下游对象会在下一轮垃圾回收时被回收。



为什么栈对象不开写屏障？也就是说栈上存储的指针变量修改是没有写屏障的，而堆对象中的指针修改是有的。  **因为go通过逃逸分析，尽量将对象都放在栈上，协程会很多，那么对所有栈的指针都开启写屏障开销很大，性能会很差。**



缺点：

插入写屏障：由于栈对象没有开启写屏障，GC最后还是需要STW，整体扫描一下栈对象避免回收了不该回收的对象。（举一个例子）

删除写屏障：GC开始要STW扫描每个协程的栈，将栈对象标为黑色，指向的堆对象为灰色。 不然会有错误（举一个例子）  

**话说在GC过程中创建新的栈对象指针怎么处理？GC开头确认了根对象了，这些新的应该会在下一轮**

**为什么删除写需要快照，插入写不用？ 可以看下云存储的那篇博客**

注意删除写似乎对于黑色对象直接创建指向白色对象的引用没有作为，这样导致白色对象会被误回收，不过这可以通过新对象直接为黑色解决。

### 三色标记+混合写屏障

可以发现上述两种写屏障

为了避免每次GC开始或结束时的STW，提出混合写屏障。

它的基本流程：

1. GC开始的时候，优先扫描栈，将栈上的全部可达对象标记为黑色。栈上操作是没有屏障机制的。（**疑惑**：这里不也是STW？或许GC扫描的开始栈对象会少一些，性能比最后STW扫描好？ **解答：**这里不是STW！每次阻塞一个协程并扫描它）
2. GC期间，任何在栈上创建的新对象，也全部标记为黑色。这么做也是为了避免进行二次扫描，不需要二次扫描就意味着不需要STW暂停了。那为什么标记为黑色就不需要二次扫描了呢？之所以需要扫描是因为栈上可能存在被标记为白色的合法对象，若不扫描可能会被GC回收掉。现在全部标记为黑色，就都是合法的对象，GC就不会去清理。那全部标记为黑色会不会导致内存泄露呢？并不会，因为还有删除写屏障的机制。
3. 被删除的对象标记为灰色。(这里沿用了删除写屏障的特点)
4. 被添加的对象标记为灰色。



扫描栈对象为黑色后，后面再对栈对象

1。 删除引用。没关系，仍然是黑色，下一轮GC就会回收。

2. 添加引用，如果是已存在的对象，已经是黑色了。如果是新对象，正如规则说的，都会被标记为黑色。
3. 堆对象既有添加写屏障，也有删除写屏障，比如删除堆对象引用，转让栈对象引用，虽然栈没有写屏障，但由于堆有，该对象也会是灰色， 那么最后也不需要STW扫描栈对象。



### 参考

- https://developer.aliyun.com/article/861507
- https://malcolmyu.github.io/2019/07/07/Tri-Color-Marking/
- https://alovn.cn/docs/golang/memory/gc/
- https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html
- https://go.googlesource.com/proposal/+/master/design/17503-eliminate-rescan.md





栈中会有指向堆的指针，因此是根对象。

那go语言中不为栈设置写屏障 而为堆设置是什么意思？ 栈指向的对象不是在堆里吗？
