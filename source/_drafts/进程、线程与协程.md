---
title: 进程、线程与协程
tags:
---



### 进程

进程是系统资源分配的最小单位，有着独立的地址空间。

在linux中，通过task_struct维护进程状态。

### 线程

为什么需要线程？

1. 相比进程更加轻量级。共享同一个进程的地址空间，不过每个线程有自己的寄存器、程序计数器、栈。
2. 数据通信更方便。



在linux中也是task struct，与进程一起调度。 那如何与进程区分？  tgid、pid



Linux的线程是1对1的线程模型。



调度程序在任何给定时间选择运行哪些线程时是不可预测的。线程优先级和事件(比如在网络上接收数据)使得无法确定调度程序将选择做什么以及什么时候做。

其次，它意味着您绝不能基于某些感知行为编写代码，这些行为您有幸经历过，但并不保证每次都会发生。

### 协程

有了线程，为什么还需要协程？

1. 协作式，而非抢占式。更好的控制数据的流动和逻辑的顺序。
2. 性能更好。协程上下文切换不一定更换线程，开销低，而且每个协程的栈最开始只有几kb，可增长，而线程固定8K的栈大小。



用户态的线程，对于开发者更加可控， 协程顾名思义，它们之间是协作的关系，而非相互竞争和抢夺执行权，这是其与线程最大的区别。



协程最终也是绑定到线程上，可能是多对1，也可能是多对多，对于Go而言，是多对多。



Go并不是协程，goroutinue还是会被强制抢占，后续go打算支持coroutine。



go如何实现同步的代码编写方式，底层实现异步回调的呢？

>   Go netpoller 通过在底层对 epoll/kqueue/iocp 的封装，从而实现了使用同步编程模式达到异步执行的效果。总结来说，所有的网络操作都以网络描述符 netFD 为中心实现。netFD 与底层 PollDesc 结构绑定，当在一个 netFD 上读写遇到 EAGAIN 错误时，就将当前 goroutine 存储到这个 netFD 对应的 PollDesc 中，同时调用 gopark 把当前 goroutine 给 park 住，直到这个 netFD 上再次发生读写事件，才将此 goroutine 给 ready 激活重新运行。显然，在底层通知 goroutine 再次发生读写等事件的方式就是 epoll/kqueue/iocp 等事件驱动机制。

`netFD.accept` 方法里会再调用 `poll.FD.Accept` ，最后会使用 Linux 的系统调用 `accept` 来完成新连接的接收，并且会把 accept 的 socket 设置成非阻塞 I/O 模式。

`pollDesc.waitRead` 方法主要负责检测当前这个 pollDesc 的上层 netFD 对应的 fd 是否有『期待的』I/O 事件发生，如果有就直接返回，否则就 park 住当前的 goroutine 并持续等待直至对应的 fd 上发生可读/可写或者其他『期待的』I/O 事件为止，然后它就会返回到外层的 for 循环，让 goroutine 继续执行逻辑。

