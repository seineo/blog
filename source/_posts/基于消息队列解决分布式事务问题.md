---
title: 基于消息队列解决分布式事务问题
date: 2023-12-16 16:52:40
tags:
---


## 引例

最近自己在做的项目有一个简单的需求：生成账户注册所需的验证码后给用户邮箱发送验证码邮件。为了可扩展性，我将整个系统划分为了一个个微服务，那么对于这个需求，也就是**账户服务**需要在生成验证码后通知**邮箱服务**发送邮件。

我们需要验证码生成与邮件发送一起成功或一起失败，因此这是一个分布式事务问题。解决分布式事务业界有一些经典的方法，如两阶段提交（Two-phase Commit，2PC）、三阶段提交、消息队列等，最终我选择了消息队列这一方式，原因如下：

- **高性能**：相比于2PC的长时间锁定与大量的通信开销，消息队列通常能提供较高的吞吐量和较低的延迟。

- **系统解耦**：通过消息队列，系统可以实现各个服务的解耦，每个服务可以专注于自己的业务逻辑，通过消息传递来让下游服务完成它们负责的业务。
- **流量削峰**：通过消息队列，可以将突增的并发同步调用转化为异步的消息推送，从而下游服务可以根据处理能力来消费消息，避免服务器宕机。
- **最终一致性**：消息队列虽然不能实现2PC那样的强一致性，但可以通过合理的设计实现最终一致性，使得系统在一段时间内达到一致状态。

## 业务数据与事件消息的一致性

对于这一问题，我第一反应是同步事件投递的方式，如下图所示，账户服务在生成并存储验证码后，同步地向消息队列投递事件消息。

<img src="https://oss.seineo.cn/images/202312152358086.png" alt="截屏2023-12-15 23.58.48" style="zoom: 67%;" />

这似乎很完美，如果存储验证码或者写入消息失败，账户服务的本地事务都会回滚，保证业务数据与事件消息的一致性。

但其实这样仍然会有不一致的情况，如下图所示，如果消息已写入消息队列，但是在第6步返回时由于网络原因超时，那么账户服务的事务会回滚，验证码并不会被存储，但已存储的消息后续会被消费，这导致了业务数据与事件消息的不一致。

<img src="https://oss.seineo.cn/images/202312160002179.png" alt="截屏2023-12-16 00.02.10" style="zoom: 67%;" />

上述问题本质是因为**本地事务无法准确获知事件存储的状态**，因此可以在本地存储事件消息的状态，再异步地定时查询未发布的事件，将他们发布即可，如下图所示。

<img src="https://oss.seineo.cn/images/202312160032384.png" alt="截屏2023-12-16 00.32.08" style="zoom: 67%;" />

未发布的事件不是发布后就标记为已处理，如果这样的话，比如第11步消费方消费失败时，由于消息已经读取且发布方已经标记为该事件已处理，那么该事件就丢失了，邮件并未发送出去。那么何时标记呢？在消费方消费完成后通知发布方已消费，发布方再进行标记，具体如何通知见后文。 

## 消息处理的幂等性

我们的目光来到消息的消费方，定时检查事件投递、消息队列本身的重试等都可能会使得消费方收到重复的消息，如果重复地消费了消息，不幂等的消息处理会严重影响用户体验或造成损失，比如引例中重复发送了邮件会使用户困惑，如果消费方的处理是金额的增加或扣除，则更是大事故。

为了确保不重复消费，我们可以让消费方也存储事件：维护一个本地消费事件表，收到消息时尝试插入一条事件消息，如果**因为重复标识而插入失败，则说明收到了重复的消息，丢弃该消息**。当然，完成这一点需要每个事件都有着唯一的ID，这可以通过分布式ID生成算法（如Twitter的Snowflake算法）来解决。

如下图所示，邮件服务插入消费事件成功（第12步）后则开始业务逻辑，此处为发送邮件，完成事务后再向消息队列写入已消费该事件的消息，账户服务收到后将对应的事件修改为已消费即可。至此事件完成，该事件不会再被账户服务的定时任务选中并投递到消息队列了。

<img src="https://oss.seineo.cn/images/202312161709044.png" alt="截屏2023-12-16 17.02.48" style="zoom: 67%;" />

这里有一个问题，邮箱服务也要通过消息队列通知账户服务，那是不是也一样需要事件表呢？需要的话那岂不是账户服务又要通知邮箱服务已消费，这样就陷入了死循环了。

仔细分析邮箱服务的11到14步，如果业务逻辑完成（此处为邮件已发送），那么消费事件就已经记录在表中了，即使事务结束后第15步发送事件已消费的消息失败，账户服务定时扫描后重复发送该事件，邮箱服务也会因为事件已在表中而不重复消费，**插入失败时也回复事件已消费的消息给账户服务**，这样最终也会让事件标记为已消费。

## 总结

至此，我们可以总结出一套基于消息队列解决分布式事务问题的流程，如下图所示：

![截屏2023-12-16 16.10.06](https://oss.seineo.cn/images/202312161610704.png)

这一流程重点在于解决两个问题：

1. 如何保证消息不丢失？

2. 如何保证消息不重复消费？

对于第一点，需要发布方确认消费方收到消息并消费完成，这是通过发布方本地的事件存储以及消费方确认消费完成后的回应事件来实现的。

对于第二点，消费方可以利用事件的唯一标识，只处理第一次接收到的事件，后续重复的事件将回应已消费事件来让发布方不再发送该事件。
